Index: src/main/java/Agents/Agent.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package Agents;\r\n\r\nimport Controller.Variables;\r\nimport Controller.Vector;\r\nimport Path.Move;\r\nimport Path.Position;\r\n\r\nimport java.lang.Math;\r\n\r\nimport java.util.ArrayList;\r\n\r\n/*\r\ngoal: last tile in vision in the alpha direction is the goal\r\nwhen you reach goal\r\n */\r\n\r\n\r\npublic class Agent  {\r\n    //INSTANCES of class Agent\r\n    //Agent Team information\r\n    int teamCode; //1 if Intruder, 0 if Guard\r\n\r\n    Variables variables = new Variables();\r\n    private int mapPosX; //relative to map\r\n    private int mapPosY;\r\n    private int spawnX;\r\n    private int spawnY;\r\n    private double initialAngle;\r\n    private double currentAngle;\r\n    private String strategy;\r\n    private String  GO_TO_END = \"end\";\r\n    private String  GO_TO_SPAWN = \"spawn\";\r\n    private String  GO_ALONG_END = \"along_end\";\r\n    private String AVOID_WALL = \"avoid_wall\";\r\n    private String  EXPLORE = \"explore\";\r\n    private boolean avoidWall;\r\n    private int avoidance;\r\n    private int agentSize;\r\n    private int teamSize;\r\n    private int visionRange = variables.getDistanceViewing();\r\n    private double visionWidth;\r\n    private Agent[] team;\r\n    private ArrayList<int[]> exploredFields = new ArrayList<>();\r\n    private ArrayList<int[]> visibleFields = new ArrayList<>(); //what the agent sees\r\n    /**/\r\n    private Vector orientation;\r\n    private Map map; //whole map\r\n    private int mapMaxX;\r\n    private int mapMaxY;\r\n    private int[] endOfVisionRange;\r\n    private int[] lastVisited;\r\n    private ArrayList<int[]> path;\r\n    private int iterator;\r\n\r\n    //Agent Geographical Informations\r\n\r\n    int[] spawning = new int [4]; // starting zone of the team\r\n    int agentPositionX; //relative to spawn\r\n    int agentPositionY; //as above\r\n\r\n     /* It is interesting for each agent to contain a copy of the map\r\n     * but  when updating the map this also means updating each of the agents memory\r\n      */\r\n    int[][] agentGoal;//current Goal for its A*\r\n    ArrayList<int[]> agentTrace = new ArrayList<>();\r\n    ArrayList<int[]> flags = new ArrayList<>();\r\n    //Agent Actions\r\n    Move agentMove; // update for agent itself and the Map\r\n     //int direction; // we try to split the 360 in a smart way\r\n\r\n    //Agent Range features\r\n    double getHearing; // ? for PHASE 2\r\n    private int[] visionLeft;\r\n    private int[] visionRight;\r\n    private int[] aGoal;\r\n\r\n    private NeoExploAlgoPerAgent exploAlgoMachine;\r\n\r\n    private int WalltoAvoid;\r\n    private int sideWall;\r\n    private int flagCounter;\r\n    private int stepCounter;\r\n    private int turnCounter;\r\n    private int[] lastPosition = new int [2];\r\n\r\n\r\n\r\n    /* METHOD(1): Agent\r\n     *   constructor\r\n     *   create an agent belonging to a specific team\r\n     * */\r\n    public Agent(int team, Variables vars){\r\n        this.visionWidth = java.lang.Math.toRadians(15);\r\n        this.teamCode = team;\r\n        this.variables = vars;// FileParser.readFile(\"./resources/testmap.txt\");\r\n        //team = new Agent[variables.getNumberOfGuards()];\r\n        ArrayList<Integer> spawnCoords = variables.getSpawnAreaGuards().getCoords();\r\n        if(team == 0){\r\n            this.teamSize = variables.getNumberOfGuards();\r\n        }\r\n        else if (team == 1){\r\n            this.teamSize = variables.getNumberOfIntruders();\r\n        }\r\n        this.agentPositionX = 0; //whenever agent moves, we have to update this\r\n        this.agentPositionY = 0;\r\n\r\n        this.visionRange = variables.getDistanceViewing();\r\n        this.orientation = new Vector(this.agentPositionX,this.agentPositionY,this.initialAngle,this.visionRange);\r\n        this.mapMaxX = variables.getWidth();\r\n        this.mapMaxY = variables.getHeight();\r\n\r\n        exploAlgoMachine = new NeoExploAlgoPerAgent();\r\n        path = new ArrayList<>();\r\n        iterator = 0;\r\n    }\r\n    /**\r\n     * DOCUMENTATION FOR ZOFIA'S PART\r\n     *\r\n     * 1 : move\r\n     * 2 : pathFinished\r\n     * 3 : getPathFromAstar\r\n     * 4 : getNextMove\r\n     * 5 : setInitialCoords\r\n     * 6 : turn\r\n     * 7 : dropFlag\r\n     * 8 : isInMap\r\n     * 9 : currentlyVisibleFields\r\n     * 10 : lastSeenField\r\n     * 11 : setVision\r\n     * 12 : convertToMap\r\n     * 13 : convertToAgent\r\n     * 14 : goal\r\n     * 15 : updateStrategy\r\n     * 16 : shouldGoToSpawnAngle\r\n     * 17 : reachedWallFlag()\r\n     * 18 : isAtSpawn\r\n     * 19 : reachedEnd\r\n     * 20 : reachedWall\r\n     * 21 : nextCoord\r\n     * 22 : goToEndOfMapCoords\r\n     * 23 : exploreEdgeCoords\r\n     * 24 : gotoSpawnCorrds\r\n     * 25 : explore\r\n     * */\r\n\r\n    public void move(){\r\n        int[] coords = new int[2];\r\n        coords[0] = this.agentPositionX;\r\n        coords[1] = this.agentPositionY;\r\n        setLastVisited(coords);\r\n        if(pathFinished()){\r\n            aGoal = goal();\r\n            path = getPathFromAstar();\r\n            this.iterator = 0;\r\n        }\r\n        else{\r\n            coords = getNextMove();\r\n        }\r\n        //ArrayList<Integer> path = getPathFromAstar();\r\n        //nextMove = path(0);\r\n        //path(0).delete;\r\n        /*\r\n        * Some methods that change the agent position, to do in the connection\r\n        * */\r\n        int[] mapCoords = convertToMap(this.agentPositionX,this.agentPositionY);\r\n        this.mapPosX = mapCoords[0];\r\n        this.mapPosY = mapCoords[1];\r\n    }\r\n\r\n    private boolean pathFinished(){\r\n        return iterator == path.size();\r\n    }\r\n\r\n    private ArrayList<int[]> getPathFromAstar(){\r\n        Position startPosition = new Position(this.mapPosX,this.mapPosY);\r\n        Position goal = new Position(this.aGoal[0],this.aGoal[1]);\r\n        return agentMove.getPath(startPosition, goal, this.map);\r\n    }\r\n\r\n    private int[] getNextMove(){\r\n        iterator++;\r\n        return path.get(iterator-1);\r\n    }\r\n\r\n    public void setInitialCoords(int[] coords){\r\n        this.spawnX = coords[0];\r\n        this.spawnY = coords[1];\r\n        this.mapPosX = spawnX;\r\n        this.mapPosY = spawnY;\r\n    }\r\n\r\n    public void turn(double alpha){\r\n        /** angle expressed in radians counter clockwise*/\r\n        this.orientation.turn(alpha);\r\n        setVision();\r\n    }\r\n\r\n    private void dropFlag(){\r\n        this.map.getTile(this.mapPosX,this.mapPosY).placeFlag();\r\n        int[] coords = new int[2];\r\n        coords[0] = this.mapPosX;\r\n        coords[1] = this.mapPosY;\r\n        this.flags.add(coords);\r\n    }\r\n\r\n    private boolean isInMap(int x, int y){\r\n        return x>=0 && x<this.mapMaxX && y>=0 && y<this.mapMaxY;\r\n    }\r\n\r\n    private boolean isInMap(int[] c){\r\n        return c[0]>=0 && c[0]<this.mapMaxX && c[1]>=0 && c[1]<this.mapMaxY;\r\n    }\r\n\r\n    private ArrayList<int[]> currentlyVisibleFields() {\r\n        return this.visibleFields;\r\n    }\r\n\r\n    private int[] lastSeenField(){\r\n        return this.visibleFields.get(this.visibleFields.size()-1);\r\n    }\r\n    /*\r\n    * vision is set to be a line of tiles, in the direction of the orientation vector and the length of vision range\r\n    * this method sets the visibleFields parameter. (used for exploration updating)\r\n    * */\r\n\r\n    private void setVision(){\r\n        ArrayList<int[]> fields = new ArrayList<int[]>();\r\n\r\n        int a1=0,a2=0,b1=0,b2=0;\r\n        double conditionAngle = this.orientation.getAngle() - Math.toRadians(22.5);\r\n        if(conditionAngle>=Math.toRadians(360-45) && conditionAngle<Math.toRadians(45)){\r\n            a1 = 0; a2=0;\r\n            b1 = 1; b2 = -1;\r\n        }\r\n        else if(conditionAngle>=Math.toRadians(45) && conditionAngle<Math.toRadians(90)){\r\n            a1 = 1; a2 = 0;\r\n            b1 = 0; b2 = 1;\r\n        }\r\n        else if(conditionAngle>=Math.toRadians(90) && conditionAngle<Math.toRadians(90+45)){\r\n            a1=1; a2=-1;\r\n            b1=0;b2=0;\r\n        }\r\n        else if(conditionAngle>=Math.toRadians(90+45) && conditionAngle<Math.toRadians(180)){\r\n            a1=0;a2=-1;\r\n            b1=1;b2=0;\r\n        }\r\n        else if(conditionAngle>=Math.toRadians(180) && conditionAngle<Math.toRadians(180+45)){\r\n            a1=0;a2=0;\r\n            b1=1;b2=-1;\r\n        }\r\n        else if(conditionAngle>=Math.toRadians(180+45) && conditionAngle<Math.toRadians(270)){\r\n            a1=-1;a2=0;\r\n            b1=0;b2=-1;\r\n        }\r\n        else if(conditionAngle>=Math.toRadians(270) && conditionAngle<Math.toRadians(270+45)){\r\n            a1 = -1; a2=1;\r\n            b1=0;b2=0;\r\n        }\r\n        else if(conditionAngle>=Math.toRadians(270+45) && conditionAngle<Math.toRadians(360)){\r\n            a1=0;a2=1;\r\n            b1=-1;b2=0;\r\n        }\r\n        int[] coords = new int[2];\r\n        coords[0] = this.mapPosX+a1;\r\n        coords[1] = this.mapPosY+b1;\r\n        this.visionLeft = coords;\r\n        if(isInMap(coords[0],coords[1])) {\r\n            fields.add(coords);\r\n            if (!exploredFields.contains(coords)) {\r\n                exploredFields.add(coords);\r\n            }\r\n        }\r\n        coords[0]=this.mapPosX+a2;\r\n        coords[1]=this.mapPosY+b2;\r\n        this.visionRight = coords;\r\n        if(isInMap(coords[0],coords[1])) {\r\n            fields.add(coords);\r\n            if (!exploredFields.contains(coords)) {\r\n                exploredFields.add(coords);\r\n            }\r\n        }\r\n\r\n        for(int i =0; i<=this.visionRange; i++){\r\n            double ratio = Math.abs(this.orientation.getY2()/this.orientation.getX2());\r\n            int x = i;\r\n            int y = (int) (ratio*x);\r\n            coords = convertToMap(x,y);\r\n            fields.add(coords);\r\n            if(!exploredFields.contains(coords)){\r\n                exploredFields.add(coords);\r\n            }\r\n            if(map.getTile(x,y).hasWall() || !isInMap(x,y)){\r\n                //this.orientation.setLength(i);\r\n                break;\r\n            }\r\n        }\r\n\r\n        this.endOfVisionRange = fields.get(fields.size()-1);\r\n        this.visibleFields = fields;\r\n    }\r\n\r\n\r\n    private int[] convertToMap(int x, int y){\r\n        /**\r\n         * takes relative x,y from agent's POV\r\n         * */\r\n        int[] coords = new int[2];\r\n        coords[0]=this.agentPositionX + this.spawnX;\r\n        coords[1]=this.agentPositionY + this.spawnY;\r\n        return coords;\r\n    }\r\n\r\n    private int[] convertToAgent(int xMap, int yMap){\r\n        /**\r\n         * takes map's x,y and converts to relative agent coords\r\n         * */\r\n        int[] coords = new int[2];\r\n        coords[0]=xMap - this.spawnX;\r\n        coords[1]=yMap - this.spawnY;\r\n        return coords;\r\n    }\r\n\r\n\r\n    /** GETTERS **/\r\n\r\n    public Map getAgentMap(){return map;}\r\n    public int[] getAgentSpawning(){return spawning;}\r\n    public int getAgentPositionX(){return this.mapPosX;}\r\n    public int getAgentPositionY(){return this.mapPosY;}\r\n    public int[][] getAgentGoal(){return this.agentGoal;}\r\n    public double getInitialAngle(){\r\n        return initialAngle;\r\n    }\r\n    public Tile[][] getTiles(){\r\n        return this.map.getTiles();\r\n    }\r\n\r\n    public ArrayList<int[]> getExplored(){\r\n        return this.exploredFields;\r\n    }\r\n    public int[] getLastVisited(){\r\n        return this.lastVisited;\r\n    }\r\n    public ArrayList<int[]> getAgentTrace(){\r\n        return agentTrace;\r\n    }\r\n    public ArrayList<int[]> getFlags(){\r\n        return this.flags;\r\n    }\r\n\r\n    public ArrayList<int[]> getVisibleFields(){\r\n        return  this.visibleFields;\r\n    }\r\n\r\n    public int[] getCurrentCoordinates() {\r\n        int[] coords = new int[2];\r\n        coords[0] = this.mapPosX;\r\n        coords[1] = this.mapPosY;\r\n        return coords;\r\n    }\r\n\r\n    /** SETTERS **/\r\n    public void setCurrentAngle(double alpha){\r\n        this.orientation.setAngle(alpha);\r\n        setVision();\r\n    }\r\n    public void setInitialAngle(double angle ){this.initialAngle = angle; }\r\n    public void setAgentPositionX(int agentPositionX){this.mapPosX = agentPositionX;}\r\n    public void setAgentPositionY(int agentPositionY){this.mapPosY = agentPositionY;}\r\n    private void setLastVisited(int[] coords){this.lastVisited = coords;}\r\n\r\n    public void setLastPosition(int x, int y ){this.lastPosition[0]= x; this.lastPosition[1]= y;}\r\n    public int [] getLastPosition(){return this.lastPosition;}\r\n    // initial orientation of the Wall to Avoid\r\n    public void setWalltoAvoid(int wall){this.WalltoAvoid = wall;}\r\n    public int getWalltoAvoid(){return this.WalltoAvoid;}\r\n    public void resetWalltoAvoid(){ this.WalltoAvoid = 0;}\r\n\r\n    //side orientation of the wall to Avoid\r\n    public void setSideWall(int wall){this.sideWall = wall;}\r\n    public int getSideWall(){return this.sideWall;}\r\n    public void resetSideWall(){ this.sideWall = 0;}\r\n\r\n    // the Agent tracks the number of flags left behind\r\n    public void resetFlagCounter(){this.flagCounter =0;}\r\n    public void increaseFlagCounter(){ this.flagCounter++;}\r\n    public int getFlagCounter(){return this.flagCounter;}\r\n\r\n    //the Agent tracks the number of steps(move&turns) performed\r\n    public void resetStepsCounter(){this.stepCounter =0;}\r\n    public void increaseStepsCounter(){this.stepCounter++;}\r\n    public void decreaseStepsCounter(){this.stepCounter--;}\r\n    public int getStepsCounter(){return this.stepCounter;}\r\n\r\n    //the Agent tracks the number of turn(move&turns) performed\r\n    public void resetTurnCounter(){this.turnCounter =0;}\r\n    public void increaseTurnCounter(){this.turnCounter++;}\r\n    public void decreaseTurnCounter(){this.turnCounter--;}\r\n    public int getTurnCounter(){return this.turnCounter;}\r\n\r\n\r\n\r\n\r\n    /*\r\n    * HELPER METHOD to create a VECTOR END POINT\r\n    *  INPUT: an angle and a distance\r\n    * OUTPUT: the end coordonate of the Route vector\r\n    * */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /*METHOD (4) AGENT STRATEGY\r\n    * CONTENT: each agent gets a specific exploration strategy to cover the map heavenly\r\n    *  this exploration can be subdivised into 3 main routes:\r\n    *       1/ from spawn Zone to map limit\r\n    *       2/ from map limit to the nearest trace\r\n    *       3/ finally back to spawn Zone\r\n    *\r\n    *       On the way it is possible to encounter obstacles such as walls, other agents trace or téléportation doors\r\n    *          We created subroutines for each of these eventualities\r\n    * */\r\n\r\n\r\n\r\n\r\n        //WALL AVOIDANCE METHOD\r\n    // until front position contains wall, avoid by the right\r\n    //until side\r\n\r\n\r\n\r\n    public int[] goal(){\r\n        /**\r\n         * returns an array of 2 coordinates that define the goal based ont the current strategy\r\n         * */\r\n        updateStrategy();\r\n        switch(this.strategy){\r\n            case \"end\":\r\n                return goToEndOfMapCoords();\r\n            case \"along_end\":\r\n                return  exploreEdgeCoords();\r\n            case \"spawn\":\r\n                return goToSpawnCoords();\r\n            case \"avoid_wall\":\r\n                //return wall();\r\n                break;\r\n            case \"explore\":\r\n                return explore();\r\n        }\r\n        return getCurrentCoordinates();\r\n    }\r\n\r\n\r\n\r\n\r\n    private void updateStrategy(){\r\n        /**\r\n         * updates the strategy of the agent\r\n         * */\r\n\r\n        if(reachedWall()){\r\n            this.avoidWall = true;\r\n        }\r\n\r\n        if(strategy.equals(GO_TO_END) && reachedEnd()){\r\n            this.strategy = GO_ALONG_END;\r\n        }\r\n        else if(this.avoidWall && reachedWallFlag()){\r\n            this.strategy = GO_TO_SPAWN;\r\n        }\r\n        if(strategy.equals(GO_ALONG_END) && shouldGoToSpawnAngle()){\r\n            this.strategy = GO_TO_SPAWN;\r\n        }\r\n        if(strategy.equals(GO_TO_SPAWN) && isAtSpawn()){\r\n            this.strategy = EXPLORE;\r\n        }\r\n    }\r\n\r\n    /*\r\n    * shouldGoToSpawnAngle uses trig functions to determine\r\n    * whether the agent has covered their designated angle\r\n    * */\r\n\r\n    private boolean shouldGoToSpawnAngle(){\r\n        /**\r\n         * returns true if agent should go back to spawn (ANGLE STRATEGY)\r\n         * */\r\n        int k = (int) this.initialAngle/this.teamSize;\r\n        double alpha = initialAngle;\r\n        double k_alpha = (k-1)*alpha;\r\n        double ratioTan = 0.0;\r\n        if(k_alpha == 0 || Math.abs(k_alpha) == Math.PI/2 || Math.abs(k_alpha) == 3*Math.PI/2){\r\n            return this.agentPositionY == 0;\r\n        }\r\n        else if (k == 0){\r\n            k_alpha = (this.teamSize - 1) * alpha;\r\n        }\r\n        ratioTan = (double) this.agentPositionY/this.agentPositionX;\r\n\r\n\r\n        return Math.tan(k_alpha) == ratioTan;\r\n    }\r\n\r\n    private boolean shouldGoToSpawnTrace(){\r\n        int[] coords = nextCoord();\r\n        boolean b = map.getTile(coords[0], coords[1]).hasTrace();\r\n        return b;\r\n    }\r\n\r\n    private boolean reachedWallFlag(){\r\n        int[] coords = nextCoord();\r\n        if(isInMap(coords[0],coords[1])){\r\n            return map.getTile(coords[0],coords[1]).hasFlag();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private boolean isAtSpawn(){\r\n        return agentPositionX == 0 && agentPositionY == 0;\r\n    }\r\n\r\n    private boolean reachedEnd(){\r\n        int[] coords = nextCoord();\r\n        return !isInMap(coords[0],coords[1]);\r\n    }\r\n\r\n    private boolean reachedWall(){\r\n        int[] coords = nextCoord();\r\n        return this.map.getTile(coords[0],coords[1]).hasWall();\r\n    }\r\n\r\n    private int[] nextCoord(){\r\n        /**\r\n         * returns the coordinates of the first tile\r\n         * */\r\n        Vector unitVec = this.orientation.unitCopy();\r\n        int[] coords = unitVec.getEndCoords();\r\n        return convertToMap(coords[0],coords[1]);\r\n    }\r\n\r\n\r\n    /** STRATEGY IMPLEMENTATION METHODS*/\r\n\r\n    private int[] goToEndOfMapCoords(){\r\n        return this.endOfVisionRange; //unless wall evasion, to correct!\r\n    }\r\n\r\n    /*\r\n    * for exploreEdgeCoords(): I divide the map into 4 parts relative to spawn point.\r\n    * If agent is in the top right:\r\n    * check if he can move (if next field is on map)\r\n    * turn him so that he is oriented to 0 degrees (East)\r\n    * If can move then -> just go along the wall\r\n    * If cant move still -> orient agent to 270 degrees (South)\r\n    * */\r\n\r\n    private int[] exploreEdgeCoords(){\r\n        /**returns the next set of coordinates for the go along end of map strategy*/\r\n        double alpha = 0.0;\r\n        int[] coords = new int[2];\r\n        if(reachedEnd()){\r\n            if(this.agentPositionX>=0 && this.agentPositionY>=0){\r\n                if(this.currentAngle == Math.toRadians(0)){\r\n                    setCurrentAngle(Math.toRadians(270));\r\n                }\r\n                else {\r\n                    this.currentAngle = Math.toRadians(0);\r\n                }\r\n            }\r\n            else if(this.agentPositionX<0 && this.agentPositionY>0){\r\n                if(this.currentAngle == Math.toRadians(90)){\r\n                    setCurrentAngle(Math.toRadians(0));\r\n                }\r\n                else{\r\n                    setCurrentAngle(Math.toRadians(90));\r\n                }\r\n            }\r\n            else if(this.agentPositionX<0 && this.agentPositionY<0){\r\n                if(this.currentAngle == Math.toRadians(180)){\r\n                    setCurrentAngle(Math.toRadians(90));\r\n                }\r\n                else{\r\n                    setCurrentAngle(Math.toRadians(180));\r\n                }\r\n            }\r\n            else if(this.agentPositionX > 0 && this.agentPositionY < 0){\r\n                if(this.currentAngle == Math.toRadians(0)){\r\n                    setCurrentAngle(Math.toRadians(90));\r\n                }\r\n                else{\r\n                    setCurrentAngle(Math.toRadians(0));\r\n                }\r\n            }\r\n            coords[0] = this.mapPosX;\r\n            coords[1] = this.mapPosY;\r\n            return coords;\r\n        }\r\n        else{\r\n            return nextCoord();\r\n        }\r\n    }\r\n\r\n    private int[] goToSpawnCoords(){\r\n        this.orientation = new Vector(this.agentPositionX,this.agentPositionY,0,0);\r\n        this.orientation.setLength(this.visionRange);\r\n        setVision();\r\n        return this.visibleFields.get(this.visibleFields.size() - 1);\r\n    }\r\n\r\n    private int[] explore(){\r\n        return exploAlgoMachine.explore(this);\r\n    }\r\n\r\n    /*******************************************************************************\r\n     *                               @TIPHANIE'S methods (documentation)\r\n     * METHOD (1): Wall avoidance\r\n     * METHOD (2): start Avoidance\r\n     * METHOD(3):  End_Avoidance\r\n     * METHOD(4): resetAvoidance\r\n     * METHOD(5): mesureSteps\r\n     * METHOD(6): moveCase\r\n     * METHOD (7) : isWall\r\n     * METHOD (8) : cases\r\n     *\r\n     * METHOD (9): wall_North\r\n     * METHOD (10): wall_South\r\n     * METHOD (11): wall_East\r\n     * METHOD (12): wall_West\r\n     * METHOD (13) : switchWallLeft\r\n     * METHOD (14) : switchWallRight\r\n     */\r\n\r\n\r\n\r\n    /*******************************************************************************\r\n     * METHOD (1): Wall avoidance: a control baord\r\n     * TO DO: customize lines 360 and 361 into a boolean conditions to call the current method\r\n     ********************************************************************************/\r\n    public int[] wallAvoidance(){ // to be called from Goal\r\n        if(End_Avoidance() == false){\r\n            if(getFlagCounter() == 0){\r\n                startAvoidance();//initialize the parameters\r\n            }\r\n            return moveCase();\r\n        }\r\n        else {\r\n            resetAvoidance();\r\n            //        dropFlag();//LAST FLAG\r\n            int[] finalPos = new int[2];\r\n            finalPos[0] = getAgentPositionX();\r\n            finalPos[1] = getAgentPositionY();\r\n            return finalPos;\r\n        }\r\n    }\r\n\r\n    /***************************************************************************\r\n     * METHOD (2): start Avoidance\r\n     *  set the parameters for the wall avoidance\r\n     ****************************************************************************/\r\n    public void startAvoidance(){\r\n        //memorize the type of challenge\r\n        int wallType = isWall();\r\n        if(wallType != 0){\r\n            /*\r\n             * TO DO: put a flag at getAgentPositionX();\r\n             */\r\n            setWalltoAvoid(wallType);\r\n            dropFlag(); //oNLY UNIVERSAL FLAG\r\n            increaseFlagCounter();\r\n            System.out.println(\"flagcounter at \" + getFlagCounter());\r\n        }\r\n        System.out.println(\"No need to set start: already or no wall\");\r\n    }//end startAvoidance\r\n\r\n    /* **************************************************************************\r\n     * METHOD(3):  End_Avoidance\r\n     *  a security because normally goal wont call it anymore !! DOUBLE  CHECK\r\n     * Detects when the agent has successfully crossed the wall\r\n     * Thats when he transition from having the wall to the North of his position\r\n     *    to having the !!same wall!! at his South\r\n     *    the current way might fail in narrow corridors...\r\n     *  terminate back to original vertical/horizontal coordonates\r\n     *  works under condition that the getWalltoAvoid() remains unchanged throughout the entire procedure\r\n     ***************************************************************************/\r\n    public boolean End_Avoidance(){\r\n\r\n        if(reachedEnd()){\r\n            // dble security *\r\n            return true;\r\n        }\r\n        else if(getFlagCounter() > 0 && getStepsCounter() == 0 ){\r\n            if(getWalltoAvoid() == 1 && wall_South() == true)\r\n                return true;\r\n            else if(getWalltoAvoid() == 2 && wall_North() == true)\r\n                return true;\r\n            else if(getWalltoAvoid() == 3 && wall_East() == true)\r\n                return true;\r\n            else if(getWalltoAvoid() == 4 && wall_West() == true)\r\n                return true;\r\n            else if(getStepsCounter() > 200){// in case the Agent got stuck\r\n                System.out.println(\"security exit \" + getStepsCounter());\r\n                return true;\r\n            }\r\n        }\r\n        return false; //otherwise keep avoidig the wall\r\n    }// end of End_Avoidance\r\n\r\n    /***************************************************************************\r\n     * METHOD(4): resetAvoidance\r\n     *  Make sure to initialize on null or zero at Agent Creation\r\n     * Reset every parameters used by wall avoidance\r\n     ***************************************************************************/\r\n    public void resetAvoidance(){\r\n        resetFlagCounter();\r\n        resetStepsCounter();\r\n        resetWalltoAvoid();\r\n        resetSideWall();\r\n    }\r\n\r\n    /***************************************************************************\r\n     * METHOD(5): mesureSteps\r\n     * only increase step counter in first branch\r\n     ****************************************************************************/\r\n    public void mesureSteps(){\r\n        if(wasWall() == getWalltoAvoid()){\r\n            increaseStepsCounter();\r\n        }\r\n    }\r\n\r\n    /*****************************************************************************\r\n     * METHOD(6): moveCase\r\n     * for a definite case associate the correct move to perform\r\n     ******************************************************************************/\r\n    public int[] moveCase(){\r\n        int [] miniGoal = new int [2];// contains x, y positions of next move\r\n        int casE = cases();\r\n\r\n        if(casE == 1  || getSideWall() == 1 ){// go left\r\n            miniGoal[0] = getAgentPositionX()+1;\r\n            miniGoal[1] = getAgentPositionY();\r\n        }\r\n        else if(casE == 2  || getSideWall() == 2){// go right\r\n            miniGoal[0] = getAgentPositionX()-1;\r\n            miniGoal[1] = getAgentPositionY();\r\n        }\r\n        else if(casE == 3 || getSideWall() == 3){//go down\r\n            miniGoal[0] = getAgentPositionX();\r\n            miniGoal[1] = getAgentPositionY()-1;\r\n        }\r\n        else if(casE == 4 || getSideWall() == 4){//go up\r\n            miniGoal[0] = getAgentPositionX();\r\n            miniGoal[1] = getAgentPositionY()+1;\r\n        }\r\n        //the #3 STAHL CASES : turn will be performed in different context\r\n        else if(casE == 5 || casE == 6 || casE == 7){\r\n\r\n            if(casE == 5 ){//when the space ahead is free: turn to the LEFT always\r\n                setSideWall(switchWallLeft());//left wall considered\r\n                turn(Math.toRadians(90));\r\n            }\r\n            else if(casE == 6 || casE == 7 ){//when the space ahead is not free: turn to the LEFT always\r\n                if(getTurnCounter() == 0 && casE == 6 ) {\r\n                    turn(Math.toRadians(90)); //make it a RIGHT TURN !!!!!!!!!\r\n                    //  setSideWall(switchWallRight()); //will the turn counter enter the above conditions ?\r\n                    setSideWall(getWalltoAvoid());//so the next time it will enter the above position\r\n                    increaseTurnCounter();\r\n                }\r\n                else if(getTurnCounter() == 0 && (casE == 6 ||casE == 7 ) ) {\r\n                    turn(Math.toRadians(90)); //make it a RIGHT TURN !!!!!!!!!\r\n                    increaseTurnCounter();\r\n                    resetTurnCounter();\r\n                }\r\n                else if(getTurnCounter() == 1 && casE == 7){\r\n                    turn(Math.toRadians(90)); //make it a RIGHT TURN !!!!!!!!!\r\n                    setSideWall(switchWallRight()); //make sure the agent position is being updated at that stage !\r\n                } //from here the procedure should execute base on classic cases 1 to 4\r\n\r\n                else if(getTurnCounter() == 2 && casE == 7){\r\n                    setSideWall(switchWallRight()); //make sure the agent position is being updated at that stage !\r\n                    resetTurnCounter();\r\n                }\r\n            }\r\n            miniGoal[0] = getAgentPositionX();\r\n            miniGoal[1] = getAgentPositionY();\r\n        }//end of #3 STAHL CASES\r\n\r\n        /* Phase 1 and 2: the agent hasn't come across the obstacle\r\n         * Current wall is parallel to the inital avoidance\r\n         */\r\n        if((getFlagCounter()<2) && (isWall() == getWalltoAvoid() )){\r\n            mesureSteps();\r\n        }\r\n        else if(getFlagCounter() == 2){\r\n            decreaseStepsCounter();\r\n            System.out.print(\"remaining steps\" + getStepsCounter());\r\n        }\r\n        setLastPosition(miniGoal[0],miniGoal[1]);\r\n        return miniGoal;\r\n\r\n    }//end of move Case\r\n\r\n\r\n\r\n    /*****************************************************************************\r\n     * METHOD (7) : isWall\r\n     * if the agent has reached a goal this identifies which type\r\n     ******************************************************************************/\r\n    public int isWall(){\r\n        //somewhere in the surrounding\r\n        Tile[][] Copy = getAgentMap().getTiles();\r\n        if(Copy[agentPositionX][agentPositionY+1].hasWall() == true){\r\n            return 1;  //NORTH CASE\r\n        }\r\n\r\n        else if(Copy[agentPositionX][agentPositionY-1].hasWall() == true){\r\n            return 2;   //SOUTH CASE\r\n        }\r\n\r\n        else if(Copy[getAgentPositionX()-1][getAgentPositionY()].hasWall() == true){\r\n            return 3;   //EAST CASE\r\n        }\r\n\r\n        else if(Copy[getAgentPositionX()+1][getAgentPositionY()].hasWall() == true){//check for outoff bound errors\r\n            return 4;   //WEST CASE\r\n        }\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    public int wasWall(){\r\n        //somewhere in the surrounding\r\n        Tile[][] Copy = getAgentMap().getTiles();\r\n        if(Copy[getLastPosition()[0]][getLastPosition()[1]+1].hasWall() == true){\r\n            return 1;  //NORTH CASE\r\n        }\r\n\r\n        else if(Copy[getLastPosition()[0]][getLastPosition()[1]-1].hasWall() == true){\r\n            return 2;   //SOUTH CASE\r\n        }\r\n\r\n        else if(Copy[getLastPosition()[0]-1][getLastPosition()[1]].hasWall() == true){\r\n            return 3;   //EAST CASE\r\n        }\r\n\r\n        else if(Copy[getLastPosition()[0]+1][getLastPosition()[1]].hasWall() == true){//check for outoff bound errors\r\n            return 4;   //WEST CASE\r\n        }\r\n        else\r\n            return 0;\r\n    }\r\n    /*****************************************************************************\r\n     * METHOD (8) : cases\r\n     * identify the wall orientation\r\n     ******************************************************************************/\r\n    public int cases(){\r\n        int casE = 0;\r\n        //CASE (1): go right , increase abscisse by one whenever\r\n        if(wall_North() == true && getFlagCounter() == 0){\r\n            casE = 1;\r\n        }\r\n        else if (wall_South()== true && getFlagCounter() == 2){\r\n            casE = 1;\r\n        }\r\n        else if(wall_West()== true && getFlagCounter() == 1){\r\n            casE = 1;\r\n        }\r\n        //CASE (2): go left\r\n        else if(wall_North() == true && getFlagCounter() == 2){\r\n            casE = 2;\r\n        }\r\n        else if (wall_South() == true && getFlagCounter() == 0){\r\n            casE = 2;\r\n        }\r\n        else if(wall_East() == true && getFlagCounter() == 1){\r\n            casE = 2;\r\n        }\r\n        //CASE (3): go down\r\n        else if(wall_East() == true && getFlagCounter() == 0){\r\n            casE = 3;\r\n        }\r\n        else if (wall_West() == true && getFlagCounter() == 2){\r\n            casE = 3;\r\n        }\r\n        else if(wall_South() == true && getFlagCounter() == 1){\r\n            casE = 3;\r\n        }\r\n        //CASE (4): go up\r\n        else if(wall_West() == true && getFlagCounter() == 0){\r\n            casE = 4;\r\n        }\r\n        else if (wall_East() == true && getFlagCounter() == 2){\r\n            casE = 4;\r\n        }\r\n        else if(wall_North() == true && getFlagCounter() == 1){\r\n            casE = 4;\r\n        }\r\n        else if( wasWall() == getWalltoAvoid() && isWall() == 0){\r\n            /*\r\n             * Turn is required whenever we go out of the wall area\r\n             * Stick vision concept: the tile on the right of the agent is free\r\n             * Tif vision, call the latest stored wall avoidance\r\n             */\r\n            casE = 5;\r\n        }//2 WALLS BLOCKING THE AGENT\r\n        else if(wasWall() == getWalltoAvoid() && isWall() == switchWallLeft(/*getWalltoAvoid()*/)){\r\n            /*LONGUER WAY: more obstacles on the way, keep circuling around  */\r\n            casE = 6;\r\n        }\r\n        /* DEAD_END: 3 WALLS BLOCKING THE AGENT:\r\n         * requires to turn 180° to go back to previous steps: call switch twice\r\n         * NB 1: this method will overide the previous one\r\n         * NB 2. detection is garantied by the radius of isWall()\r\n         */\r\n      else if(wasWall() == getWalltoAvoid()\r\n                && isWall() == switchWallLeft(/*getWalltoAvoid()*/)\r\n                && isWall() == switchWallRight(/*getWalltoAvoid()*/)){\r\n            casE = 7;\r\n        }\r\n        return casE;\r\n    }\r\n\r\n    /*****************************************************************************\r\n     * A group of 4 method that identify the wall's position\r\n     * METHOD (9): wall_North\r\n     * METHOD (10): wall_South\r\n     * METHOD (11): wall_East\r\n     * METHOD (12): wall_West\r\n     * TO DO: !Check if using the stick would be more consistent\r\n     *****************************************************************************/\r\n    public boolean wall_North(){\r\n        Tile[][] Copy = getAgentMap().getTiles();\r\n        if(Copy[getAgentPositionX()][getAgentPositionY()+1].hasWall() == true){\r\n            return true;\r\n        }\r\n        else\r\n            return false;\r\n    }\r\n    public boolean wall_South(){\r\n        Tile[][] Copy = getAgentMap().getTiles();\r\n        if(Copy[getAgentPositionX()][getAgentPositionY()-1].hasWall() == true){\r\n            return true;\r\n        }\r\n        else\r\n            return false;\r\n    }\r\n    public boolean wall_East(){\r\n        Tile[][] Copy = getAgentMap().getTiles();\r\n        if(Copy[getAgentPositionX()+1][getAgentPositionY()].hasWall() == true){\r\n            return true;\r\n        }\r\n        else\r\n            return false;\r\n    }\r\n    public boolean wall_West(){\r\n        Tile[][] Copy = getAgentMap().getTiles();\r\n        if(Copy[getAgentPositionX()-1][getAgentPositionY()].hasWall() == true){//check for outoff bound errors\r\n            return true;\r\n        }\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /*****************************************************************************\r\n     * METHOD (13) : switchWallLeft\r\n     * updates sideWall reference when turning left\r\n     ******************************************************************************/\r\n    public int switchWallLeft(){\r\n        if(wasWall() == 1){//north left turn is west\r\n            return 4;\r\n        }\r\n        else if(wasWall() == 2){//south  left turn is east\r\n            return 3;\r\n        }\r\n        else if(wasWall() == 3){//west  left turn is south\r\n            return 2;\r\n        }\r\n        else if(wasWall() == 4){//east  left turn is north\r\n            return 1;\r\n        }\r\n        return 0;\r\n    }\r\n    /*****************************************************************************\r\n     * METHOD (14) : switchWallRight\r\n     * updates sideWall reference when turning right\r\n     ******************************************************************************/\r\n    public int switchWallRight(){\r\n        //first turn : 90°\r\n        if(getWalltoAvoid() == 1 && getTurnCounter() == 0){//north right turn is east\r\n            return 3;\r\n        }\r\n        else if(getWalltoAvoid()  == 2 && getTurnCounter() == 0){//south  right turn is west\r\n            return 4;\r\n        }\r\n        else if(getWalltoAvoid() == 3 && getTurnCounter() == 0){//west  right turn is north\r\n            return 1;\r\n        }\r\n        else if(getWalltoAvoid() ==  4 && getTurnCounter() == 0){//east  right turn is south\r\n            return 2;\r\n        }\r\n        //second turn : 180°\r\n        else if(getWalltoAvoid() == 1 && getTurnCounter() == 1){//north right turn is east\r\n            return 2;\r\n        }\r\n        else if(getWalltoAvoid()  == 2 && getTurnCounter() == 1){//south  right turn is west\r\n            return 1;\r\n        }\r\n        else if(getWalltoAvoid() == 3 && getTurnCounter() == 1){//west  right turn is north\r\n            return 4;\r\n        }\r\n        else if(getWalltoAvoid() ==  4 && getTurnCounter() == 1){//east  right turn is south\r\n            return 3;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/Agents/Agent.java b/src/main/java/Agents/Agent.java
--- a/src/main/java/Agents/Agent.java	(revision d92784703fa1a3799a4ca348d651d3a6c6232178)
+++ b/src/main/java/Agents/Agent.java	(date 1647868480600)
@@ -156,6 +156,7 @@
         else{
             coords = getNextMove();
         }
+
         //ArrayList<Integer> path = getPathFromAstar();
         //nextMove = path(0);
         //path(0).delete;
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"99094a21-1a8a-4d5d-8078-78165bded4be\" name=\"Changes\" comment=\"\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/Agents/Agent.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/Agents/Agent.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/Agents/Map.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/Agents/Map.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/Agents/Tile.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/Agents/Tile.java\" afterDir=\"false\" />\r\n    </list>\r\n    <list id=\"4910b3c3-583e-4d41-81aa-1bc7a6f4af65\" name=\"Changes by nathaliebent\" comment=\"\" />\r\n    <list id=\"5dfe30e5-581f-4166-b1ab-9f15b324981e\" name=\"Changes by tiphanie\" comment=\"\" />\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Interface\" />\r\n        <option value=\"Class\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Merge.Settings\">\r\n    <option name=\"BRANCH\" value=\"algoWithoutControllers\" />\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\r\n      <map>\r\n        <entry key=\"$PROJECT_DIR$\" value=\"AStar\" />\r\n      </map>\r\n    </option>\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"GitSEFilterConfiguration\">\r\n    <file-type-list>\r\n      <filtered-out-file-type name=\"LOCAL_BRANCH\" />\r\n      <filtered-out-file-type name=\"REMOTE_BRANCH\" />\r\n      <filtered-out-file-type name=\"TAG\" />\r\n      <filtered-out-file-type name=\"COMMIT_BY_MESSAGE\" />\r\n    </file-type-list>\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"MavenImportPreferences\">\r\n    <option name=\"generalSettings\">\r\n      <MavenGeneralSettings>\r\n        <option name=\"useMavenConfig\" value=\"true\" />\r\n      </MavenGeneralSettings>\r\n    </option>\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"256KGD7WaqHSuu6w26u96APtVh7\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\">\r\n    <ConfirmationsSetting value=\"2\" id=\"Add\" />\r\n  </component>\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">\r\n    <property name=\"RunOnceActivity.OpenProjectViewOnStart\" value=\"true\" />\r\n    <property name=\"RunOnceActivity.ShowReadmeOnStart\" value=\"true\" />\r\n    <property name=\"codeWithMe.voiceChat.enabledByDefault\" value=\"false\" />\r\n    <property name=\"project.structure.last.edited\" value=\"Project\" />\r\n    <property name=\"project.structure.proportion\" value=\"0.0\" />\r\n    <property name=\"project.structure.side.proportion\" value=\"0.0\" />\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"99094a21-1a8a-4d5d-8078-78165bded4be\" name=\"Changes\" comment=\"\" />\r\n      <created>1644842061035</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1644842061035</updated>\r\n    </task>\r\n    <servers />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision d92784703fa1a3799a4ca348d651d3a6c6232178)
+++ b/.idea/workspace.xml	(date 1647868481032)
@@ -7,8 +7,6 @@
     <list default="true" id="99094a21-1a8a-4d5d-8078-78165bded4be" name="Changes" comment="">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/main/java/Agents/Agent.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/Agents/Agent.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/Agents/Map.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/Agents/Map.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/Agents/Tile.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/Agents/Tile.java" afterDir="false" />
     </list>
     <list id="4910b3c3-583e-4d41-81aa-1bc7a6f4af65" name="Changes by nathaliebent" comment="" />
     <list id="5dfe30e5-581f-4166-b1ab-9f15b324981e" name="Changes by tiphanie" comment="" />
